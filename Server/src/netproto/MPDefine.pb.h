// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MPDefine.proto

#ifndef PROTOBUF_MPDefine_2eproto__INCLUDED
#define PROTOBUF_MPDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
namespace MPMsg {
}  // namespace MPMsg

namespace MPMsg {

namespace protobuf_MPDefine_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_MPDefine_2eproto

enum MsgType {
  eMsgType_Client = 0,
  eMsgType_Super2Center = 1,
  eMsgType_Center2Super = 2,
  eMsgType_Gate2Super = 3,
  eMsgType_Super2Gate = 4,
  eMsgType_Game2Super = 5,
  eMsgType_Super2Game = 6,
  eMsgType_Gate2Game = 7,
  eMsgType_Game2Gate = 8,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = eMsgType_Client;
const MsgType MsgType_MAX = eMsgType_Game2Gate;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum EGameEventCode {
  EGEC_SUCCESS = 0,
  EGEC_UNKOWN_ERROR = 1,
  EGameEventCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EGameEventCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EGameEventCode_IsValid(int value);
const EGameEventCode EGameEventCode_MIN = EGEC_SUCCESS;
const EGameEventCode EGameEventCode_MAX = EGEC_UNKOWN_ERROR;
const int EGameEventCode_ARRAYSIZE = EGameEventCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGameEventCode_descriptor();
inline const ::std::string& EGameEventCode_Name(EGameEventCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGameEventCode_descriptor(), value);
}
inline bool EGameEventCode_Parse(
    const ::std::string& name, EGameEventCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGameEventCode>(
    EGameEventCode_descriptor(), name, value);
}
enum ESynMsgID {
  ESMI_UNKNOW = 0,
  ESynMsgID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ESynMsgID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ESynMsgID_IsValid(int value);
const ESynMsgID ESynMsgID_MIN = ESMI_UNKNOW;
const ESynMsgID ESynMsgID_MAX = ESMI_UNKNOW;
const int ESynMsgID_ARRAYSIZE = ESynMsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ESynMsgID_descriptor();
inline const ::std::string& ESynMsgID_Name(ESynMsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ESynMsgID_descriptor(), value);
}
inline bool ESynMsgID_Parse(
    const ::std::string& name, ESynMsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ESynMsgID>(
    ESynMsgID_descriptor(), name, value);
}
enum EGameMsgID {
  EGMI_UNKNOW = 0,
  EGMI_EVENT_RESULT = 1,
  EGMI_EVENT_TRANSPOND = 2,
  EGameMsgID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EGameMsgID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EGameMsgID_IsValid(int value);
const EGameMsgID EGameMsgID_MIN = EGMI_UNKNOW;
const EGameMsgID EGameMsgID_MAX = EGMI_EVENT_TRANSPOND;
const int EGameMsgID_ARRAYSIZE = EGameMsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGameMsgID_descriptor();
inline const ::std::string& EGameMsgID_Name(EGameMsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGameMsgID_descriptor(), value);
}
inline bool EGameMsgID_Parse(
    const ::std::string& name, EGameMsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGameMsgID>(
    EGameMsgID_descriptor(), name, value);
}
enum Gate2Super_Msg {
  eGate2Super_Unkonwn = 0,
  eGate2Super_VerifyMe = 1,
  Gate2Super_Msg_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Gate2Super_Msg_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Gate2Super_Msg_IsValid(int value);
const Gate2Super_Msg Gate2Super_Msg_MIN = eGate2Super_Unkonwn;
const Gate2Super_Msg Gate2Super_Msg_MAX = eGate2Super_VerifyMe;
const int Gate2Super_Msg_ARRAYSIZE = Gate2Super_Msg_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gate2Super_Msg_descriptor();
inline const ::std::string& Gate2Super_Msg_Name(Gate2Super_Msg value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gate2Super_Msg_descriptor(), value);
}
inline bool Gate2Super_Msg_Parse(
    const ::std::string& name, Gate2Super_Msg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gate2Super_Msg>(
    Gate2Super_Msg_descriptor(), name, value);
}
enum Gate2Game_Msg {
  eGameMsg_Unknown = 0,
  eGameMsg_GameMsgWrapper = 1,
  eGameMsg_GameUserLogonSuccess = 2,
  eGameMsg_GateUserLogout = 3,
  Gate2Game_Msg_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Gate2Game_Msg_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Gate2Game_Msg_IsValid(int value);
const Gate2Game_Msg Gate2Game_Msg_MIN = eGameMsg_Unknown;
const Gate2Game_Msg Gate2Game_Msg_MAX = eGameMsg_GateUserLogout;
const int Gate2Game_Msg_ARRAYSIZE = Gate2Game_Msg_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gate2Game_Msg_descriptor();
inline const ::std::string& Gate2Game_Msg_Name(Gate2Game_Msg value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gate2Game_Msg_descriptor(), value);
}
inline bool Gate2Game_Msg_Parse(
    const ::std::string& name, Gate2Game_Msg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gate2Game_Msg>(
    Gate2Game_Msg_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)


}  // namespace MPMsg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MPMsg::MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::MsgType>() {
  return ::MPMsg::MsgType_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::EGameEventCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::EGameEventCode>() {
  return ::MPMsg::EGameEventCode_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::ESynMsgID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::ESynMsgID>() {
  return ::MPMsg::ESynMsgID_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::EGameMsgID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::EGameMsgID>() {
  return ::MPMsg::EGameMsgID_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::Gate2Super_Msg> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::Gate2Super_Msg>() {
  return ::MPMsg::Gate2Super_Msg_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::Gate2Game_Msg> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::Gate2Game_Msg>() {
  return ::MPMsg::Gate2Game_Msg_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MPDefine_2eproto__INCLUDED
