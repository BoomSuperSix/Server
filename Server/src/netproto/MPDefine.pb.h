// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MPDefine.proto

#ifndef PROTOBUF_MPDefine_2eproto__INCLUDED
#define PROTOBUF_MPDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
namespace MPMsg {
}  // namespace MPMsg

namespace MPMsg {

namespace protobuf_MPDefine_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_MPDefine_2eproto

enum EGameEventCode {
  EGEC_SUCCESS = 0,
  EGEC_UNKOWN_ERROR = 1,
  EGameEventCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EGameEventCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EGameEventCode_IsValid(int value);
const EGameEventCode EGameEventCode_MIN = EGEC_SUCCESS;
const EGameEventCode EGameEventCode_MAX = EGEC_UNKOWN_ERROR;
const int EGameEventCode_ARRAYSIZE = EGameEventCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGameEventCode_descriptor();
inline const ::std::string& EGameEventCode_Name(EGameEventCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGameEventCode_descriptor(), value);
}
inline bool EGameEventCode_Parse(
    const ::std::string& name, EGameEventCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGameEventCode>(
    EGameEventCode_descriptor(), name, value);
}
enum ESynMsgID {
  ESMI_UNKNOW = 0,
  ESynMsgID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ESynMsgID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ESynMsgID_IsValid(int value);
const ESynMsgID ESynMsgID_MIN = ESMI_UNKNOW;
const ESynMsgID ESynMsgID_MAX = ESMI_UNKNOW;
const int ESynMsgID_ARRAYSIZE = ESynMsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ESynMsgID_descriptor();
inline const ::std::string& ESynMsgID_Name(ESynMsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ESynMsgID_descriptor(), value);
}
inline bool ESynMsgID_Parse(
    const ::std::string& name, ESynMsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ESynMsgID>(
    ESynMsgID_descriptor(), name, value);
}
enum EGameMsgID {
  EGMI_UNKNOW = 0,
  EGMI_EVENT_RESULT = 1,
  EGMI_EVENT_TRANSPOND = 2,
  EGameMsgID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EGameMsgID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EGameMsgID_IsValid(int value);
const EGameMsgID EGameMsgID_MIN = EGMI_UNKNOW;
const EGameMsgID EGameMsgID_MAX = EGMI_EVENT_TRANSPOND;
const int EGameMsgID_ARRAYSIZE = EGameMsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGameMsgID_descriptor();
inline const ::std::string& EGameMsgID_Name(EGameMsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGameMsgID_descriptor(), value);
}
inline bool EGameMsgID_Parse(
    const ::std::string& name, EGameMsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGameMsgID>(
    EGameMsgID_descriptor(), name, value);
}
enum GateSuper_Msg {
  eGate2Super_Unkonwn = 0,
  eGate2Super_VerifyMe = 1,
  GateSuper_Msg_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GateSuper_Msg_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GateSuper_Msg_IsValid(int value);
const GateSuper_Msg GateSuper_Msg_MIN = eGate2Super_Unkonwn;
const GateSuper_Msg GateSuper_Msg_MAX = eGate2Super_VerifyMe;
const int GateSuper_Msg_ARRAYSIZE = GateSuper_Msg_MAX + 1;

const ::google::protobuf::EnumDescriptor* GateSuper_Msg_descriptor();
inline const ::std::string& GateSuper_Msg_Name(GateSuper_Msg value) {
  return ::google::protobuf::internal::NameOfEnum(
    GateSuper_Msg_descriptor(), value);
}
inline bool GateSuper_Msg_Parse(
    const ::std::string& name, GateSuper_Msg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GateSuper_Msg>(
    GateSuper_Msg_descriptor(), name, value);
}
enum GateGame_Msg {
  eGameMsg_Unknown = 0,
  eGameMsg_GameMsgWrapper = 1,
  eGameMsg_GameUserLogonSuccess = 2,
  eGameMsg_GateUserLogout = 3,
  GateGame_Msg_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GateGame_Msg_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GateGame_Msg_IsValid(int value);
const GateGame_Msg GateGame_Msg_MIN = eGameMsg_Unknown;
const GateGame_Msg GateGame_Msg_MAX = eGameMsg_GateUserLogout;
const int GateGame_Msg_ARRAYSIZE = GateGame_Msg_MAX + 1;

const ::google::protobuf::EnumDescriptor* GateGame_Msg_descriptor();
inline const ::std::string& GateGame_Msg_Name(GateGame_Msg value) {
  return ::google::protobuf::internal::NameOfEnum(
    GateGame_Msg_descriptor(), value);
}
inline bool GateGame_Msg_Parse(
    const ::std::string& name, GateGame_Msg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GateGame_Msg>(
    GateGame_Msg_descriptor(), name, value);
}
enum GameSuper_Msg {
  eGame2Super_Unknown = 0,
  eGame2Super_GameMsgWrapper = 1,
  GameSuper_Msg_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GameSuper_Msg_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GameSuper_Msg_IsValid(int value);
const GameSuper_Msg GameSuper_Msg_MIN = eGame2Super_Unknown;
const GameSuper_Msg GameSuper_Msg_MAX = eGame2Super_GameMsgWrapper;
const int GameSuper_Msg_ARRAYSIZE = GameSuper_Msg_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameSuper_Msg_descriptor();
inline const ::std::string& GameSuper_Msg_Name(GameSuper_Msg value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameSuper_Msg_descriptor(), value);
}
inline bool GameSuper_Msg_Parse(
    const ::std::string& name, GameSuper_Msg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameSuper_Msg>(
    GameSuper_Msg_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)


}  // namespace MPMsg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MPMsg::EGameEventCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::EGameEventCode>() {
  return ::MPMsg::EGameEventCode_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::ESynMsgID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::ESynMsgID>() {
  return ::MPMsg::ESynMsgID_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::EGameMsgID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::EGameMsgID>() {
  return ::MPMsg::EGameMsgID_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::GateSuper_Msg> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::GateSuper_Msg>() {
  return ::MPMsg::GateSuper_Msg_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::GateGame_Msg> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::GateGame_Msg>() {
  return ::MPMsg::GateGame_Msg_descriptor();
}
template <> struct is_proto_enum< ::MPMsg::GameSuper_Msg> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MPMsg::GameSuper_Msg>() {
  return ::MPMsg::GameSuper_Msg_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MPDefine_2eproto__INCLUDED
